Add Row Polymorphism to Haskell
==============

.. proposal-number:: Leave blank. This will be filled in when the proposal is
                     accepted.
.. trac-ticket:: Leave blank. This will eventually be filled with the Trac
                 ticket number which will track the progress of the
                 implementation of the feature.
.. implemented:: Leave blank. This will be filled in with the first GHC version which
                 implements the described feature.
.. highlight:: haskell
.. header:: This proposal is `discussed at this pull request <https://github.com/ghc-proposals/ghc-proposals/pull/180>`_.
.. sectnum::
.. contents::

This is a proposal to introduce a new built-in kind, ``Row k``, to allow to describe labeled, polymorphic types such as Records or Variants. To construct types of this kind a new syntax is added. This also adds a few builtin constraints to help with the manipulation of those types. This new syntax is completely backwards compatible. The second part of the proposal is to add a new extendsion ``PolymorphicRecords`` that changes the Record syntax to be syntactic sugar over a phantom-typed Record datatype.

Motivation
------------

The current record syntax is just a syntactic sugar for a normal product type. This implies that all record types are their own type and there is no way to describe an operation that works over all records of a certain shape.

A common use case is when defining web APIs. The user should ``POST`` a serialized equivalent of a haskell record data type to an enpoint, excluding the ID of the object (as it is generated by the database later. However, after saving the object in the database the ID will always be defined, so making the ID optional by typing it as ``Maybe`` is also not the correct thing to do. Here the example uses ``servant`` as example because of its type level description.

.. code-block:: haskell

  data User = User { id :: Int, name :: String } deriving Generic

  type API = "user" :> ReqBody '[JSON] User :> Post '[JSON] Id -- now the user has to provide an id

Note that this example show also another use case: using ``id`` as label of a record. Currently this is not possible, because ``id`` is the identity function in Prelude and the generated accessor function collides with this definition.

There were already multiple discussions about adding polymorphic record types to Haskell, but the problem of them was that it is hard to decide on the semantics of the new feature. This comment from `the Haskell mailing list <https://mail.haskell.org/pipermail/haskell/2008-February/020177.html>`_ is a very good summary:

.. code-block:: haskell

  This sort of disagreement means that nothing gets done. After my
  experience with the wiki page, I don't believe anything will get done
  until one of the core ghc developers makes some arbitrary decisions
  and implements whatever they want to, which will then eventually
  become part of the standard by default.

There are mainly two reasons why I open this proposal now:

- It exists a widely used language that is very similar to Haskell that has successfully implemented Rows and extensible Records (`PureScript <http://www.purescript.org/>`_)
- There is no central place (like this repository) where opinions about this topic are collected and discussed

Proposed Change Specification
-----------------------------

The semantics of rows are taken from `this paper <https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/scopedlabels.pdf>`_. These are the same semantics that PureScript also implements currently. Note that the semantics of Records differ from the paper!

1. Rows:

The first part of the proposal is to add a new language extension ``-XRowPolymorphism`` that allows to use a new syntax to construct types of a new kind ``Row``.

A row is a new kind ``Row k`` (ie is a kind constructor). A row of types is used to associate labels with types. The proposed syntax to construct such a type is (pseudo grammar):

.. code-block:: haskell

  row ::= '(' [rowFields] ['|' (typeVar | row)] ')'
  rowFields ::= label '::' type [',' rowFields]

**NOTE**: This syntax does indeed collide with ``-XKindAnnotations`` with ``-XDataKinds``, mentioned by [@lspitzner](https://github.com/ghc-proposals/ghc-proposals/pull/180#issuecomment-437715806):

.. code-block:: haskell

  type Foo a = (a :: Bool) -- Row of label a and type Bool, with phantom parameter
                           -- or a kind annotation?

A few examples for this syntax:

.. code-block:: haskell

  type MyRow a = (foo :: Int, bar :: a) -- kind: `Row Type`; a inferred as kind `Type`

  type MyOpenRow r = (foo :: Int, bar :: String | r) -- kind `Row Type`; r inferred as kind `Row Type`

  type NatRow = (foo :: 6, bar :: 7) -- kind `Row Nat`

The second example shows the extension of a Row with another. For this, they have to be the same kind, so the ``k`` of both rows has to match.

A ``Row k`` behaves like a type level ``Map Symbol [k]``. This means:
- The order of types with different labels is irrelevant, this means ``(foo :: Foo, bar :: Bar) ~ (bar :: Bar, foo :: Foo)``
- If a row contains duplicated labels, the order of the types appearing the row is remembered, so ``(foo :: Int, foo :: Foo)`` is not equal to ``(foo :: Foo, foo :: Int)``

Duplicated labels in rows have several advantages:
- You can always extend a row ``r`` to ``(foo :: t | r)``, no matter what ``r`` is
- Reverting the extension always returns the same ``r`` as before

A practical example for using duplicate labels is the library  `purescript-checked-exceptions <https://github.com/natefaubion/purescript-checked-exceptions>`_. It is using variants to implement checked exceptions. The need to allow duplicate labels arise from the ability to rethrow exceptions from handlers, possibly with a different type. A variant's ``on`` function matches on the label and removes it from the row indexing the variant type (basically like ``Variant (myError :: String | r) -> Variant r``. Now, if you want to rethrow errors from those handlers, the variable ``r`` has to be instanciated with ``(myError :: SomeType | r2)``, resulting in duplicated labels:

.. code-block:: haskell

  Variant (myError :: String | r) -> Variant r
  Variant (myError :: String | (myError :: SomeType | r2)) -> Variant (myError :: SomeType | r2)
  Variant (myError :: String, myError :: SomeType | r2) -> Variant (myError :: SomeType | r2)


Rows define a bunch of constraints that can be used to manipulate them, that work like a trivial type classes:

.. code-block:: haskell

  --| Either looks up the type of a label in the row
  --  returning it together with the rest of the row
  --  or allows us to get the row that would be created
  --  when extending a row with a label-type pair
  class RowCons label ty tail row | label row -> ty tail, label ty tail -> row


  --| Asserts that the row lacks the label
  class RowLacks label row

  --| Removes duplicate labels from the row
  class RowNub original nubbed | original -> nubbed

  --| Merges two rows (left-biased), includes duplicated labels
  class RowUnion left right union
        | left right -> union, right union -> left, left union -> right

2. Records

As a second step, a new type for records is introduced. This type is added to the ``base`` library. The syntax sugar to create those records is overwriting the current syntax and is enabled with a second language extension ``-XPolymorphicRecords`` that implies ``-XRowPolymorphism``.

2.1 Syntax

.. code-block:: haskell

  data Record (r :: Row Type) = Record (SmallArray# Any)

The type level syntax of a record is very similar to rows:

.. code-block:: haskell

  recordType ::= '{' [rowFields] ['|' (typeVar | row)] '}'

This is just syntactic sugar for the record type and its row:

.. code-block:: haskell

  { foo :: Foo, bar :: Bar | r } ~ Record (foo :: Foo, bar :: Bar | r)

The value level syntax is similar to the current syntax for records and the syntax in other languages:

.. code-block:: haskell

  record ::= '{' [recordFields] '}'
  recordFields ::= label ':' expression [',' recordFields]

Records can be updated with a new record update syntax:

.. code-block:: haskell

  recordUpdate ::= '{' [updateFields] '}'
  updateFields ::= label '=' expression [',' updateFields]

Records can also be used for pattern matching similar to the ``NamedFieldPuns`` extension in Haskell:

.. code-block:: haskell

  recordPun ::= '{' [punLabels] '}'
  punLabels ::= label [',' punLabels]

For a function definition this would look like this:

.. code-block:: haskell

  f { x, y } = x + y


2.2 Semantics

The standard libary provides a few functions for dealing with records. The types of those are:

In all of the following code snippets, syntax like ``#foo`` is using the ``-XOverloadedLabels`` extension.

.. code-block:: haskell

  get :: forall r r' l a. RowCons l a r' r => Proxy l -> Record r -> a

  modify :: forall r1 r2 r l a b. RowCons l a r r1 => RowCons l b r r2 =>
         Proxy l -> (a -> b) -> Record r1 -> Record r2

  insert :: forall r1 r2 l a. RowLacks l r1 => RowCons l a r1 r2 =>
         Proxy l -> a -> Record r1 -> Record r2

  delete :: forall r1 r2 l a. RowLacks l r1 => RowCons l a r1 r2 =>
         Proxy l -> Record r2 -> Record r1

The constraints on these functions mean that a record can only have each label once. A record expression is semantically equivalent to repeated ``insert``:

.. code-block:: haskell

  { foo: "foo", bar: "bar" } == insert #foo "foo" $ insert #bar "bar" {}

This also means, that while the row of a record may have duplicate types, we will never be able to construct such a type:

.. code-block:: haskell

  type MyRec = Record (foo :: Int, foo :: String)

  val :: MyRec
  val = { foo: 4, foo: "Hello" } -- type error, because:
  -- equivalent to
  val = insert #foo 4 $ { foo: "Hello" } -- insert has `RowLacks` constraint

This proposal allows open records, those are internally implemented via the ``RowCons`` constraint. As records are internally represented as array and thus need an index to return the value, the constraint is also used to carry the index of the label:

.. code-block:: haskell

  f :: { x :: Int, y :: Int | r } -> Int
  -- "desugars" to (step by step)
  f :: forall r. { x :: Int, y :: Int | r } -> Int
  f :: forall r. Record ( x :: Int, y :: Int | r ) -> Int
  f :: forall r r0. RowCons "x" Int r r0 => Record ( y :: Int | r0 ) -> Int
  f :: forall r r0 r1. RowCons "x" Int r r0 => RowCons "y" Int r0 r1 => Record ( | r1 ) -> Int
  f :: forall r r0 r1. RowCons "x" Int r r0 => RowCons "y" Int r0 r1 => Record r1 -> Int

The newly introduced type variables and the constriants always go to the ``forall`` that quantifies ``r`` (be it implicit or explicit, e.g. with ``RankNTypes``).

Type aliases and families only substitute record types, they get replaced by the constraints after expansion:

.. code-block:: haskell

  type family MyFamily (r :: Row Type) :: Type where
      WithId r = Maybe { id :: Int | r }

  f :: { | r } -> MyFamily r
  -- desugaring steps
  f :: { | r } -> Maybe { id :: Int | r }
  f :: forall r. { | r } -> Maybe { id :: Int | r }
  f :: forall r. Record ( | r ) -> Maybe (Record (id :: Int | r))
  f :: forall r. Record r -> Maybe (Record (id :: Int | r))
  f :: forall r r0. RowCons "id" Int r r0 => Record r -> Maybe (Record ( | r0))
  f :: forall r r0. RowCons "id" Int r r0 => Record r -> Maybe (Record r0)

Record updates are semanticly equivalent to the ``modify`` function:

.. code-block:: haskell

  rec = { a: "Hello" } { a = "foo" }
  -- equivalent to
  rec = modify #a (const "foo") { a: "Hello" }

Record puns are semanticly equivalent to the ``get`` function:

.. code-block:: haskell

  f :: { x :: Int, y :: Int | r } -> Int
  f { x, y } = x + y
  -- equivalent to
  f rec = let x = get #x rec
              y = get #y rec
          in x + y

Effect and Interactions
-----------------------

The first part of the propsal allows to define a Record datatype that uses a phantom type to index an internal representation including type safe accessor functions. This part is completely backwards compatible and should not have an effect on the rest of the language.

The second part is a massive breaking change to the Record syntax, a widely used feature of Haskell. Activating ``-XPolymorphicRecords`` will change the types of Records defined in the file.

Fields of records would no longer pollude the global namespace, making extensions like ``DuplicateRecordFields`` unnecessary. So the extension would also either imply or do something similar to `NoToplevelFieldSelectors <https://github.com/ghc-proposals/ghc-proposals/pull/160>`_.

Both parts should support ``-XPolyKinds`` (the ``Row`` kind takes a second kind as argument and the Record phantom type is of kind ``Row Type``). This allows for Rows that live exclusively on type level (e.g. ``Row Symbol`` or ``Row Nat``)

This proposal would also remove the need to use ``GHC.Generics`` for many common tasks like typeclass default implementations as the author can simply provide an instance for the ``Record r`` type, see for example `the aeson instances of my PoC <https://github.com/jvanbruegge/Megarecord/blob/master/src/Megarecord/Record.hs#L48>`_.

Costs and Drawbacks
-------------------
The currently proposed Row syntax looks like kind signatures (for single element rows), but the two can never be in the same place (declaration vs definition). This might be confusing to newcomers, so the syntax is up to debate.

Alternatives
------------

As an experiment I implemented all of the semantics `as a library <https://github.com/jvanbruegge/Megarecord>`_, this would mean that the only changes to the compiler would be syntactic sugar (also see the `motivation example <https://github.com/jvanbruegge/Megarecord/blob/master/app/Main.hs>`_). This approach would work and would even allow users that are not satisfied with the semantics of the standard rows/records to use ``RebindableSyntax`` to use their own, but the big problem is compile times. For type equality it is required that the type level data structure that represents the row has a "normal form", so that ``forall orig label type. Has label type orig => Insert label type (Delete label (orig)) === orig``. The data structure also has to act like a ``Map Symbol [k]``. Originally I wanted to use a type-level red-black tree for this, but a binary search tree does not have such a normal form, so I had to use a sorted cons list. This means the type families used to implement lookup etc have to do ``O(n)`` expansions and not ``O(log(n))``.

As a performance optimization it would be possible to built a type level ``Map`` kind into the compiler with builtin type families for insertion/lookup/etc, that are optimized. One important aspect would be that this Map implements type equality such that the property in the first alternative about deletion and insertion still holds.

The other alternative is obviously doing nothing.

Unresolved Questions
--------------------
The syntax for Rows is currently taken from PureScript. It however looks a bit like KindSignatures (single element Rows) but the two can never be at the same place (not ambigous). It might be a bit confusing for newcomers though. It may also be confused for type level tuples.

Also if there should be a timeframe for deprecating the current record syntax in favor of polymorphic records based on rows. This timeframe has to be very long obviously, but it might be worth discussing.

Should the Row implementation be in the compiler or in ``base`` or some sort of hybrid that does live in the standard library, but has special-cased optimizations in the compiler to avoid ``O(n)`` or ``O(nÂ²)`` expansions in type families.

How do records interact with the ``UNPACK`` pragma and strictness?

Should accessing elements of a record be possible with the standard dot notation found in most languages? This would make a similar distiction from function composition like qualified module members (no spaces). Should this syntax allow to work though newtypes? For example with a syntax similar to ``p.Point.x``?

Should records allow for duplicated fields?

Should records allow for other kinds than ``Symbol`` as labels?

Implementation Plan
-------------------

Implementing at least the new kind is the topic my bachelor thesis, no matter if this proposal gets accepted or not. Depending on the timeframe I might be able to implement the Record data type that uses the new kind. I would like to continue to develop afterwards, maybe as my Master Thesis.
Some mentorship for this would be appreciated.
