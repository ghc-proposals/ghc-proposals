Add Row Polymorphism to Haskell
==============

.. proposal-number:: Leave blank. This will be filled in when the proposal is
                     accepted.
.. trac-ticket:: Leave blank. This will eventually be filled with the Trac
                 ticket number which will track the progress of the
                 implementation of the feature.
.. implemented:: Leave blank. This will be filled in with the first GHC version which
                 implements the described feature.
.. highlight:: haskell
.. header:: This proposal is `discussed at this pull request <https://github.com/ghc-proposals/ghc-proposals/pull/180>`_.
.. sectnum::
.. contents::

This is a proposal to introduce a new built-in kind, ``Row k``, to allow to describe labeled, polymorphic types such as Records or Variants. To construct types of this kind a new syntax is added. This also adds a few builtin constraints to help with the manipulation of those types. This new syntax is completely backwards compatible. The second part of the proposal is to add a new extendsion ``PolymorphicRecords`` that changes the Record syntax to be syntactic sugar over a phantom-typed Record datatype.

Motivation
------------

The current record syntax is just a syntactic sugar for a normal product type. This implies that all record types are their own type and there is no way to describe an operation that works over all records of a certain shape.

A common use case is when defining web APIs. The user should ``POST`` a serialized equivalent of a haskell record data type to an enpoint, excluding the ID of the object (as it is generated by the database later. However, after saving the object in the database the ID will always be defined, so making the ID optional by typing it as ``Maybe`` is also not the correct thing to do. Here the example uses ``servant`` as example because of its type level description.

.. code-block:: haskell

  data User = User { id :: Int, name :: String } deriving Generic

  type API = "user" :> ReqBody '[JSON] User :> Post '[JSON] Id -- now the user has to provide an id

Note that this example show also another use case: using ``id`` as label of a record. Currently this is not possible, because ``id`` is the identity function in Prelude and the generated accessor function collides with this definition.

There were already multiple discussions about adding polymorphic record types to Haskell, but the problem of them was that it is hard to decide on the semantics of the new feature. This comment from `the Haskell mailing list <https://mail.haskell.org/pipermail/haskell/2008-February/020177.html>`_ is a very good summary:

.. code-block:: haskell

  This sort of disagreement means that nothing gets done. After my
  experience with the wiki page, I don't believe anything will get done
  until one of the core ghc developers makes some arbitrary decisions
  and implements whatever they want to, which will then eventually
  become part of the standard by default.

There are mainly two reasons why I open this proposal now:

- It exists a widely used lamanynguage that is very similar to Haskell that has successfully implemented Rows and extensible Records (`PureScript <http://www.purescript.org/>`_)
- There is no central place (like this repository) where opinions about this topic are collected and discussed

Proposed Change Specification
-----------------------------

This proposal consists of two parts. The first part adds a new kind ``Row k`` that takes another kind as argument together with some syntax to construct types of this kind:

.. code-block:: haskell

  type MyRow a = (foo :: Int, bar :: a) -- kind: `Row Type`; a inferred as kind `Type`

  type MyOpenRow r = (foo :: Int, bar :: String | r) -- kind `Row Type`; r inferred as kind `Row Type`

  type TypeLevelOnly = (foo :: 6, bar :: 7) -- kind `Row Nat`

The semantics of this propsal are from `this paper <https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/scopedlabels.pdf>`_. The most important points:

- Rows are unordered, meaning ``(foo :: Int, bar :: Int)`` is the same as ``(bar :: Int, foo :: Int)``
- Rows can contain a label multiple times, the order of those is important
- Rows can be extended by a type variable of kind ``Row k`` where the base row's and the extending row's ``k`` have to be the same

Pseudo grammar of rows:

.. code-block:: haskell

  row ::= '(' [rowFields] ['|' typeVar] ')'
  rowFields ::= label '::' type [',' rowFields]


The second part of this propsal is to change the Record syntax to by syntactic sugar for the (then newly) builtin Record datatype based on rows:

.. code-block:: haskell

  type MyRecord a = { foo :: Int, bar :: a } -- is equivalent to this:
  type MyRecord2 a = Record (foo :: Int, bar :: a)

  printName :: { name :: String | r } -> IO ()
  printName { name } = putStrLn name
  -- equivalent to
  printName2 :: RowCons "name" String r r0 => Record r0 -> IO ()
  printName2 r = putStrLn (r @. (Proxy :: Proxy "name"))

  -- defined in Data.Record
  (@.) :: RowCons s ty _ r => Record r -> Proxy s -> ty

  -- pseudo typeclass, in reality builtin constraint
  class RowCons (s :: Symbol) (ty :: k) (r1 :: Row k) (r2 :: Row k) | s ty r1 -> r2, s r2 -> ty r1

Effect and Interactions
-----------------------

The first part of the propsal allows to define a Record datatype that uses a phantom type to index an internal representation including type safe accessor functions. This part is completely backwards compatible and should not have an effect on the rest of the language.

The second part is a massive breaking change to the Record syntax, a widely used feature of Haskell. Activating ``-XPolymorphicRecords`` will change the types of Records defined in the file.

The extension would also either imply or do something similar to `NoToplevelFieldSelectors <https://github.com/ghc-proposals/ghc-proposals/pull/160>`_.

Both parts should support ``-XPolyKinds`` (the ``Row`` kind takes a second kind as argument and the Record phantom type is of kind ``Row Type``). This allows for Rows that live exclusively on type level (e.g. ``Row Symbol`` or ``Row Nat``)

This proposal would also remove the need to use ``GHC.Generics`` for many common tasks like typeclass default implementations as the author can simply provide an instance for the ``Record r`` type, see for example `the aeson instances of my PoC <https://github.com/jvanbruegge/Megarecord/blob/master/src/Megarecord/Record.hs#L48>`_.

Costs and Drawbacks
-------------------
The currently proposed Row syntax looks like kind signatures (for single element rows), but the two can never be in the same place (declaration vs definition). This might be confusing to newcomers, so the syntax is up to debate.

Alternatives
------------

As an experiment I implemented all of the semantics `as a library <https://github.com/jvanbruegge/Megarecord>`_, this would mean that the only changes to the compiler would be syntactic sugar (also see the `motivation example <https://github.com/jvanbruegge/Megarecord/blob/master/app/Main.hs>`_). This approach would work and would even allow users that are not satisfied with the semantics of the standard rows/records to use ``RebindableSyntax`` to use their own, but the big problem is compile times. For type equality it is required that the type level data structure that represents the row has a "normal form", so that ``forall orig label type. Has label type orig => Insert label type (Delete label (orig)) === orig``. The data structure also has to act like a ``Map Symbol [k]``. Originally I wanted to use a type-level red-black tree for this, but a binary search tree does not have such a normal form, so I had to use a sorted cons list. This means the type families used to implement lookup etc have to do ``O(n)`` expansions and not ``O(log(n))``.

The other alternative is obviously doing nothing.

Unresolved Questions
--------------------
The syntax for Rows is currently taken from PureScript. It however looks a bit like KindSignatures (single element Rows) but the two can never be at the same place (not ambigous). It might be a bit confusing for newcomers though.

Also if there should be a timeframe for deprecating the current record syntax in favor of polymorphic records based on rows. This timeframe has to be very long obviously, but it might be worth discussing.

Should the Row implementation be in the compiler or in ``base`` or some sort of hybrid that does live in the standard library, but has special-cased optimizations in the compiler to avoid ``O(n)`` or ``O(nÂ²)`` expansions in type families.

Implementation Plan
-------------------

Implementing at least the new kind is the topic my bachelor thesis, no matter if this proposal gets accepted or not. Depending on the timeframe I might be able to implement the Record data type that uses the new kind. I would like to continue to develop afterwards, maybe as my Master Thesis.
Some mentorship for this would be appreciated.
