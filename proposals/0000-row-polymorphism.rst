Add Row Polymorphism to Haskell
==============

.. proposal-number:: Leave blank. This will be filled in when the proposal is
                     accepted.
.. trac-ticket:: Leave blank. This will eventually be filled with the Trac
                 ticket number which will track the progress of the
                 implementation of the feature.
.. implemented:: Leave blank. This will be filled in with the first GHC version which
                 implements the described feature.
.. highlight:: haskell
.. header:: This proposal is `discussed at this pull request <https://github.com/ghc-proposals/ghc-proposals/pull/180>`_.
.. sectnum::
.. contents::

This is a proposal to introduce a new built-in kind, ``Row j k``, to allow to describe labeled, polymorphic types such as Records or Variants. To construct types of this kind a new syntax is added. This also adds a few builtin type families to allow to manipulate those types. This new syntax is completely backwards compatible.

Motivation
------------

The current record syntax is just a syntactic sugar for a normal product type. This implies that all record types are their own type and there is no way to describe an operation that works over all records of a certain shape.

A common use case is when defining web APIs. The user should ``POST`` a serialized equivalent of a Haskell record data type to an endpoint, excluding the ID of the object (as it is generated by the database later. However, after saving the object in the database the ID will always be defined, so making the ID optional by typing it as ``Maybe`` is also not the correct thing to do. Here the example uses ``servant`` because of its type level description.

.. code-block:: haskell

  data User = User { id :: Int, name :: String } deriving Generic

  type API = "user" :> ReqBody '[JSON] User :> Post '[JSON] Id -- now the user has to provide an id

Note that this example shows also another use case: using ``id`` as label of a record. Currently this is not possible, because ``id`` is the identity function in Prelude and the generated accessor function collides with this definition.

There were already multiple discussions about adding polymorphic record types to Haskell, but the problem of them was that it is hard to decide on the semantics of the new feature. This comment from `the Haskell mailing list <https://mail.haskell.org/pipermail/haskell/2008-February/020177.html>`_ is a very good summary:

    This sort of disagreement means that nothing gets done. After my
    experience with the wiki page, I don't believe anything will get done
    until one of the core ghc developers makes some arbitrary decisions
    and implements whatever they want to, which will then eventually
    become part of the standard by default.

There are mainly two reasons why I open this proposal now:

- There exists a widely used language that is very similar to Haskell that has successfully implemented Rows and extensible Records (`PureScript <http://www.purescript.org/>`_)
- There is no central place (like this repository) where opinions about this topic are collected and discussed

Proposed Change Specification
-----------------------------

The semantics of rows are taken from `this paper <https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/scopedlabels.pdf>`_. These are the same semantics that PureScript also implements currently. Note that the semantics of Records differ from the paper!

1. Rows:

A row is a new kind ``Row j k`` (ie is a kind constructor). As the most commonly used kind for ``j`` should be ``Symbol``, a new syntax is proposed (pseudo grammar):

.. code-block:: haskell

  row ::= '(' [rowFields] '|' [(typeVar | row)] ')'
  rowFields ::= label '::' type [',' rowFields]

A few examples for this syntax:

.. code-block:: haskell

  type MyRow a = (foo :: Int, bar :: a |) -- kind: `Row Symbol Type`; `a` inferred as kind `Type`

  type MyOpenRow r = (foo :: Int, bar :: String | r) -- kind `Row Symbol Type`; `r` inferred as kind `Row Symbol Type`

  type NatRow = (foo :: 6, bar :: 7 |) -- kind `Row Symbol Nat`

The second example shows the extension of a Row with another. For this, they have to be the same kind, so the ``k`` of both rows has to match.

This syntax desugars to the use of builtin construction type families:

.. code-block:: haskell

  type MyRow a = (foo :: Int, bar :: a |)
  -- becomes
  type MyRow a = RowExt "foo" Int (RowExt "bar" a RowNil)

  type MyRow2 r = (foo :: String | r)
  -- becomes
  type MyRow2 r = RowExt "foo" String r

The type families are defined like this and are built into the compiler:

.. code-block:: haskell

  type family RowExt (a :: j) (b :: k) (r :: Row j k) :: Row j k where {}
  type family RowNil :: Row j k where {}

These type families can also be used to construct rows with other kinds than ``Symbol`` as ``j``.

2. Semantics:

A ``Row j k`` behaves like a type level ``Map j [k]``. This means:

- The order of types with different labels is irrelevant, this means ``(foo :: Foo, bar :: Bar) ~ (bar :: Bar, foo :: Foo)``
- If a row contains duplicated labels, the order of the types appearing in the row is remembered, so ``(foo :: Int, foo :: Foo)`` is not equal to ``(foo :: Foo, foo :: Int)``

Duplicate labels in the base row kind are not avoidable because at the moment Haskell does not provide a mean to constrain type families, so the type of ``RowExt`` is too permissive. It turns out, this is not a limitation as types indexed by rows can still use ``RowLacks`` constraints (see section "Derived Constraints") within their API to maintain this invariant.

Additionally duplicated labels have several advantages:

- You can always extend a row ``r`` to ``(foo :: t | r)``, no matter what ``r`` is
- Reverting the extension always returns the same ``r`` as before

A practical example for using duplicate labels is the library  `purescript-checked-exceptions <https://github.com/natefaubion/purescript-checked-exceptions>`_. It is using variants to implement checked exceptions. The need to allow duplicate labels arise from the ability to rethrow exceptions from handlers, possibly with a different type. A variant's ``on`` function matches on the label and removes it from the row indexing the variant type. Now, if you want to rethrow errors from those handlers, the variable ``r`` has to be instanciated with ``(myError :: SomeType | r2)``, resulting in duplicated labels (you can see the implementation of variants in my `Proof of concept <https://github.com/jvanbruegge/Megarecord/blob/master/src/Data/Variant.hs>`_).

.. code-block:: haskell

  data Variant (r :: Row Symbol Type) = Variant String Any

  on :: forall s a b r1 r2.
        (RowCons s a r1 r2, KownSymbol s) => -- RowCons means Row r2 consist of s :: a and the tail r1
        FldProxy s -> (a -> b) -> (Variant r1 -> b) -> Variant r2 -> b

When you want to rethrow an error to catch later (``Variant r1 -> b``), the Row ``r2`` needs to allow for duplicated labels.

3. RowToList

The type families ``RowExt`` and ``RowNil`` can only be used to construct Row types, but not to inspect them. For this purpose a builtin type family is provided that convert a Row into a ordered type level list. The other direction is simply calling ``RowExt`` and ``RowNil``.

.. code-block:: haskell

  data RowList j k = RCons j k (RowList j k) | RNil

  type family RowToOrderedList (r :: Row j k) :: RowList j k where {}

  type family ListToRow (l :: RowList j k) :: Row j k where
      ListToRow ('RCons s k r) = RowExt s k (ListToRow r)
      ListToRow 'RNil = RowNil

4. Derived constraints

These type families can be used to implement other constraints in normal Haskell:

.. code-block:: haskell

  class RowToList r rl | r -> rl, rl -> r
  instance (RowToOrderedList r ~ rl, ListToRow rl ~ r) => RowToList r rl

  type family RowLacks' (s :: j) (r :: RowList j k) :: Constraint where
      RowLacks' s (RCons s _ _) = ('False ~ 'True)
      RowLacks' s (RCons s' _ r) = RowLacks s r
      RowLacks' _ RNil = ('True ~ 'True)

  class RowLacks s r
  instance (RowToOrderedList r ~ rl, RowLacks' s rl) => RowLacks s r


  type family RowConsGet (s :: j) (r :: RowList j k) (t :: RowList j k) :: Maybe (k, RowList j k) where
      RowConsGet s (RCons s k r) t = Just (k, Concat r t)
      RowConsGet s (RCons s' k r) t = RowConsGet s r (RCons s' k t)
      RowConsGet _ RNil _ = Nothing

  class RowCons s a r1 r2 | s a r1 -> r2, s r2 -> a r1
  instance (
          RowToOrderedList r2 ~ rl2, RowConsGet s rl2 'RNil ~ Just (a, rl1),
          ListToRow rl1 ~ r1, RowExt s a r1 ~ r2
      ) => RowCons s a r1 r2


   type family RowConstraint' (c :: k -> Constraint) (rl :: RowList j k) :: Constraint where
       RowConstraint' c (RowCons _ k r) = (c k, RowConstraint c r)
       RowConstraint' _ RNil = ('True ~ 'True)

   class RowConstraint (c :: k -> Constraint) (r :: Row j k)
   instance (RowToList r rl, RowConstraint' c rl) => RowConstraint c r

These constraints *may* be implemented in the compiler directly for performance reasons.

Effect and Interactions
-----------------------

The addition of row types would allow to define extensible records and polymorphic variants in standard haskell code (with the possibility to add syntactic sugar later). There are example implementations in my Proof of Concept: `Variant <https://github.com/jvanbruegge/Megarecord/blob/master/src/Data/Variant.hs>`_ and `Record <https://github.com/jvanbruegge/Megarecord/blob/master/src/Data/Record.hs>`_.

As rows can only be used as a phantom type on other data types in typeclass instances, the ``RowToList`` (or the type families) have to be used to define instances. As example see the `ToJSON <https://github.com/jvanbruegge/Megarecord/blob/master/src/Data/Record.hs#L61>`_ or the `Show <https://github.com/jvanbruegge/Megarecord/blob/master/src/Data/Record.hs#L102>`_ instances of my Proof of Concept.

Rows should support ``-XPolyKinds`` (the ``Row`` kind takes two other kinds as argument). This allows for Rows that live exclusively on type level (e.g. ``Row Symbol Symbol`` or ``Row Symbol Nat``)

Costs and Drawbacks
-------------------

The syntax may look similar to kind annotations.

Alternatives
------------

Doing nothing.

Unresolved Questions
--------------------

The syntax for Rows is currently taken from PureScript. It however looks a bit like KindSignatures. It might be a bit confusing for newcomers though. It may also be confused for type level tuples.

Implementation Plan
-------------------

Currently the plan is to implement the new kind and the supporting builtin type families as part of my bachelor thesis, no matter if this proposal gets accepted or not. The Record and Variant datatype can be adapted from my Proof of Concept.

Some mentorship for this would be appreciated.
