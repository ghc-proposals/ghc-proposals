Profiling support for safe FFI imports.
=======================================

.. author:: Andreas Klebinger
.. date-accepted::
.. ticket-url:: implementation of the feature.
.. implemented:: Leave blank. This will be filled in with the first GHC version which
                 implements the described feature.
.. highlight:: haskell
.. header:: This proposal is `discussed at this pull request <https://github.com/ghc-proposals/ghc-proposals/pull/651>`_.
.. sectnum::
.. contents::

GHC should empower users by allowing them to mark some or all safe ffi calls as relevant
for profiling instead of never accounting for time spent within them.

Motivation
----------
Sometimes when profiling a program users encounter programs for which runtime far exceeds
the time indicated in the time profile, usually sparking confusion as a result.

Most commonly this happens when a program spends much of it's time executing safe ffi calls.
Sadly currently there is no support for diagnosing such an issue in GHC's profiling mode.
Instead safe ffi calls simply do not show up in time profiles generated by GHC at all.

While this can be confusing to people unaware of how safe ffi calls interact with profiling
even expert users currently have no way to check for such issues. Nor a way to profile the impact
on performance of these ffi calls.

Therefore I propose the addition of a ways to change the profiling behaviour of ffi functions.
Both at compile and runtime.

These will allow users:

* To quickly check if safe ffi calls could be to blame for the disparity.
* To include excution time of individual safe ffi calls in runtime profiles if so desired.

Proposed Change Specification
-----------------------------

FFI imports will get a new property: ``profiling behaviour``.

A function can be **profiled** or **unprofiled**. Their difference is that:

* A **profiled** functions runtime (wall time) is included in time profiles.
* A **unprofiled** functions runtime is ignored in time profiles.

By default safe/interruptible ffi calls will be unprofiled and unsafe ffi calls profiled.
This matches current behaviour of GHC.

Setting profiling behaviour when declaring an FFI import:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When importing functions ghc will permit two new keywords: ``profiled`` and ``unprofiled``.
These can appear after or in place of the safety specification.

Precisely we extend ffi declarations from:

.. code:: ebnf

    ...
    fdecl	→	import callconv [safety] impent var :: ftype

to this

.. code:: ebnf

    ...
    fdecl	→	import callconv [safety] [profiling] impent var :: ftype
    profiling → profiled
              | unprofiled

In theory one could do without these changes by splitting profiled/non-profiled imports into
different modules and changing their behaviour via the the flags described below.
However I think this would be more cumbersome and less explicit. Which makes defining the profiling
behaviour as part of the import the better choice in my opinion.

Setting profiling behaviour on a per-module basis:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* ``-funprofiled-safe-ffi`` will mark safe ffi/interruptible calls as unprofiled.
* ``-fprofiled-safe-ffi`` will mark safe ffi/interruptible calls as profiled.

Calls will be marked as profiled/unprofiled independent of the their import declaration if
these flags are used. They don't affect unsafe ffi calls at all.

These flags eliminate the need to annotate all ffi imports manually when trying to find out where time is
spent, as they can be enabled on a per package/module basis or even for a full build.

To give a few examples ::

    -- This import will never be affected as it's an unsafe import
    foreign import stdcall unsafe "c_unsafe"
    c_unsafe :: CInt -> CInt -> CInt -> IO CInt

    -- This import will be treated as profiled under `fprofiled-safe-ffi`
    foreign import ccall safe unprofiled "memcpy"
      memcpy_freeze :: MutableByteArray# s -> MutableByteArray# s -> CSize
            -> IO (Ptr a)

    -- This import will be treated as unprofiled under `funprofiled-safe-ffi`
    foreign import ccall safe profiled "sleep"
      c_sleep :: CUInt -> IO CUInt

Setting profiling behaviour of safe ffi calls globally at runtime:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A new runtime flag ``-ps`` which will treat all safe FFI calls as ``profiled`` independent
of how they have been compiled. This is intended as an escape hatch
that allows users to quickly check if safe ffi calls might be the culprint of a performance issue
without changing their source or recompiling.

A new runtime flag ``-pu`` which will treat all safe FFI calls as unprofiled independent
of how they have been compiled.

Avoiding confusion from the use of different measures of time:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

When profiling we can measure two different notions of time (CPU Time, Wall Time)
as well as time spent in different categories:

* Time spent in the runtime system.
* Time spent executing haskell code.
* Time spent executing unsafe ffi calls.
* Time spent executing safe ffi calls.

Implementations might combine some of these into one somewhat intuitive overall
notion of time. But implementations should make it easy for both users and tools
to access not just overall time but also how much different categories contributed
to runtime and what notion of runtime (CPU/Wall time) was used to measure each category.

For example a profile may report a total runtime of 10s and a breakdown by
category for GHC could look like this::

    TOTAL TIME:         10s

    RTS:                3s Wall
        + GC            2s Wall
        + MISC          1s Wall

    MUT:                5s
        + unsafe FFI    1s Wall
        + haskell code  4s CPU

    SAFE FFI:           2s Wall

Proposed Library Change Specification
-------------------------------------

There are no library changes planned in this proposal beyond those required for TH to
support these new declarations.

Examples
--------

::

    {-# LANGUAGE ForeignFunctionInterface #-}

    import Foreign.C

    foreign import ccall safe "sleep" c_simulated_work :: Int -> IO Int

    {-# OPAQUE ffi_call #-}
    ffi_call x = {-# SCC c_ffi #-} c_simulated_work x -- Takes x seconds to run

    {-# OPAQUE some_work #-}
    -- takes about 0.5s on my arm box
    some_work :: Integer -> Integer
    some_work x = {-# SCC haskell_work #-} sum [1..x :: Integer]

    main = {-# SCC main #-} do
        print =<< ffi_call 4
        print $ some_work 15000000

In the above program we will spend 4 seconds doing "work" via an ffi call and about .5 seconds doing work
in haskell code. Currently when trying to profile code like this we get a profile that reports 100% of the time
spent under ``haskell_work`` and a runtime of merely ~0.5 seconds. Despite the real runtime being over 4 seconds.

.. code-block:: text

    ...
    total time  =        0.54 secs   (535 ticks @ 1000 us, 1 processor)
    ...

    COST CENTRE  MODULE SRC               %time %alloc

    c_ffi        Main   Main.hs:8:32-49    88.3    0.0
    haskell_work Main   Main.hs:13:40-60   11.6  100.0

But if I use my WIP branch of GHC for the same program I get something far closer to reality:

.. code-block:: text

    COST CENTRE  MODULE SRC               %time %alloc

    c_ffi        Main   Main.hs:8:32-49    93.4    0.0
    haskell_work Main   Main.hs:13:40-60    6.5  100.0

Effect and Interactions
-----------------------
The effect of this proposal is two-fold.

The flags and runtime option allow users to quickly get an idea for how long safe ffi
calls are running (wall time). Allowing them to either rule out or diagnose performance issues as
having to do with safe fii calls quickly.

The extension of the import spec for ffi calls allows users to selectively keep track of
time spent on safe ffi calls which are typically expected to be non-blocking but potentially
long-running and relevant for performance.

However safe ffi calls to blocking functions can still be ignored in time profiles by using the
default behaviour or marking them as unprofiled explicitly.

Costs and Drawbacks
-------------------
While not trivial the changes required for this proposal both in the language specification and
the GHC implementation are surprisingly small.

For people learning about profiling the proposal should not add much confusion. Safe ffi calls are
already special and something one needs to know about. Under this proposal this would merely be more
explicit.

One potential drawback of this proposal is that blocking safe ffi calls might be interpreted as
taking up system resources if such functions are marked as profiled. Either manually or via one
of the flags. However as this requires marking a blocking ffi call as safe which is opt-in this
should be a rare occurrence, far outweighed by the benefit of being able to track longer non-blocking
safe ffi calls.

The proposal also changes the notion of time used by the profiler slightly. Currently the
profiler measures only time spent executing code within a haskell context. After this proposal
safe ffi calls are another potential source of time spent in profiles. This means the total time
reported is no longer bounded by ``-N * wall_time`` and can now include non-cpu time. In particular
time tracked will consist of the sum of:

* CPU time spent executing haskell code.
* CPU time spent executing unsafe ffi calls.
* CPU time spent executing safe ffi calls.
* Wall time safe ffi calls are blocked.

Backward Compatibility
----------------------
This change would be compatible with all existing code.


Alternatives
------------
There are alternatives to diagnose runtime spent in safe ffi calls like usage of
tools like `perf`. Writing plugins measuring the time before and after ffi calls
or staring at the code base for extended periods of time.

And while in some circumstances user might still have to revert back to such methods
this proposal should limited the need to do so in common cases.

Unresolved Questions
--------------------
As author I currently have no unresolved questions.


Implementation Plan
-------------------
I (Andreas Klebinger) am interested in implementing this proposal.

Endorsements
-------------
-
